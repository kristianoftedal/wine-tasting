---
phase: 02-category-restructuring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/categories/types.ts
  - src/lib/categories/hierarchy.ts
  - src/lib/categories/index.ts
  - scripts/validate-categories.ts
autonomous: true

must_haves:
  truths:
    - "New category module defines 6 main categories: Frukt, Krydder, Urter, Blomster, Eik/fat, Mineral"
    - "Each main category has subcategories with 'annet' fallback"
    - "Generic structure terms are separated with low weight (0.8)"
    - "Validation script confirms no duplicate terms across categories"
    - "Berry terms consolidated under single 'baer' subcategory"
  artifacts:
    - path: "src/lib/categories/types.ts"
      provides: "Type definitions for CategoryPath, MainCategory, WineSubcategory"
      exports: ["CategoryPath", "MainCategory", "WineSubcategory", "LemmaDataV2"]
    - path: "src/lib/categories/hierarchy.ts"
      provides: "WINE_CATEGORIES and GENERIC_STRUCTURE_TERMS const objects"
      exports: ["WINE_CATEGORIES", "GENERIC_STRUCTURE_TERMS"]
    - path: "src/lib/categories/index.ts"
      provides: "Public exports from categories module"
    - path: "scripts/validate-categories.ts"
      provides: "Validation script for category structure"
  key_links:
    - from: "src/lib/categories/hierarchy.ts"
      to: "src/lib/categories/types.ts"
      via: "type imports"
      pattern: "import.*from.*types"
    - from: "scripts/validate-categories.ts"
      to: "src/lib/categories"
      via: "category validation"
      pattern: "WINE_CATEGORIES|GENERIC_STRUCTURE_TERMS"
---

<objective>
Create new hierarchical category module with Vinmonopolet-inspired structure and validation script

Purpose: Build the foundation for category restructuring - a parallel category module that can be validated before replacing the old flat structure. This follows the "build-validate-swap" migration pattern from research.

Output: New src/lib/categories/ module with types, hierarchy data, and validation script
</objective>

<execution_context>
@/Users/kristianoftedal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kristianoftedal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-category-restructuring/02-CONTEXT.md
@.planning/phases/02-category-restructuring/02-RESEARCH.md
@src/lib/lemmatizeAndWeight.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create categories module with types and hierarchy</name>
  <files>
    src/lib/categories/types.ts
    src/lib/categories/hierarchy.ts
    src/lib/categories/index.ts
  </files>
  <action>
Create src/lib/categories/ directory with three files:

**types.ts** - Type definitions:
```typescript
// Main categories aligned with Vinmonopolet aromahjul
export type MainCategory = 'Frukt' | 'Krydder' | 'Urter' | 'Blomster' | 'Eik/fat' | 'Mineral';

// Subcategories per main category (use 'annet' as catch-all)
export type FruktSubcategory = 'baer' | 'sitrus' | 'steinfrukt' | 'tropisk' | 'toerket' | 'annet';
export type KrydderSubcategory = 'soet' | 'varm' | 'annet';
export type UrterSubcategory = 'groenn' | 'toerket' | 'annet';
export type BlomsterSubcategory = 'annet';
export type EikSubcategory = 'fatlagring' | 'ristet' | 'annet';
export type MineralSubcategory = 'stein' | 'annet';

// Generic structure categories (separate from aroma categories)
export type GenericCategory = 'structure' | 'quality' | 'finish' | 'body' | 'acidity' | 'sweetness' | 'texture';

// Combined subcategory type
export type WineSubcategory =
  | FruktSubcategory
  | KrydderSubcategory
  | UrterSubcategory
  | BlomsterSubcategory
  | EikSubcategory
  | MineralSubcategory
  | GenericCategory;

// Category path for hierarchical lookups
export interface CategoryPath {
  main: MainCategory | 'GENERIC';
  sub: WineSubcategory;
}

// V2 lemma data with hierarchical categories
export interface LemmaDataV2 {
  lemma: string;
  weight: number;
  category: CategoryPath;
  abstraction: 'generic' | 'specific';
}

// Subcategory data structure
export interface SubcategoryData {
  terms: readonly string[];
  weight: number;
}
```

**hierarchy.ts** - Category data with const assertions:
```typescript
import type { SubcategoryData } from './types';

// Vinmonopolet-inspired wine aroma categories
// Each term belongs to exactly ONE category
export const WINE_CATEGORIES = {
  Frukt: {
    baer: {
      // Merged from old 'mørke bær' (1.7) and 'røde bær' (1.5) - averaged to 1.6
      terms: ['solbaer', 'bjoernbaer', 'blabaer', 'morell', 'kirsbaer', 'jordbaer', 'bringbaer', 'rips'],
      weight: 1.6
    },
    sitrus: {
      terms: ['sitrus', 'sitron', 'lime', 'grapefrukt'],
      weight: 1.5
    },
    steinfrukt: {
      terms: ['plomme', 'fersken', 'aprikos'],
      weight: 1.5
    },
    tropisk: {
      terms: ['tropisk', 'mango', 'ananas', 'melon'],
      weight: 1.4
    },
    toerket: {
      terms: ['toerket', 'moden', 'sviske', 'fiken', 'daddel', 'rosin'],
      weight: 1.6
    },
    annet: {
      terms: ['eple', 'paere'],
      weight: 1.4
    }
  },
  Krydder: {
    soet: {
      terms: ['vanilje', 'kanel'],
      weight: 1.7
    },
    varm: {
      terms: ['pepper', 'nellik'],
      weight: 1.7
    },
    annet: {
      terms: ['krydder', 'krydrete', 'anis', 'lakris'],
      weight: 1.7
    }
  },
  Urter: {
    groenn: {
      terms: ['gress', 'urter', 'urtete', 'timian', 'rosmarin', 'laurbaer', 'salvie'],
      weight: 1.3
    },
    annet: {
      terms: ['mynte', 'eukalyptus'],
      weight: 1.3
    }
  },
  Blomster: {
    annet: {
      terms: ['blomster', 'blomst', 'blomstrete', 'rose', 'fiol'],
      weight: 1.3
    }
  },
  'Eik/fat': {
    fatlagring: {
      terms: ['eik', 'fat', 'fatpreg', 'fatlagret'],
      weight: 1.8
    },
    ristet: {
      terms: ['toast', 'ristet'],
      weight: 1.8
    },
    annet: {
      terms: ['noett', 'kaffe', 'sjokolade', 'honning', 'karamell', 'smoer', 'kjeks', 'broed', 'broeddeig', 'brioche', 'tjaere', 'tobakk', 'laer'],
      weight: 1.4
    }
  },
  Mineral: {
    stein: {
      terms: ['mineralsk', 'mineralitet', 'mineraler', 'stein', 'steinet', 'flint'],
      weight: 1.5
    },
    annet: {
      terms: [],
      weight: 1.5
    }
  }
} as const satisfies Record<string, Record<string, SubcategoryData>>;

// Generic structure terms - LOWER weight (0.8) per user decision
// These are abstract qualities that don't demonstrate specific tasting skill
export const GENERIC_STRUCTURE_TERMS = {
  structure: {
    terms: ['struktur', 'balanse', 'tannin', 'snerp', 'garvestoffer'],
    weight: 0.8
  },
  quality: {
    terms: ['konsentrasjon', 'dybde', 'dyp', 'kompleks', 'sammensatt', 'elegant'],
    weight: 0.8
  },
  finish: {
    terms: ['ettersmak', 'avslutning', 'finish', 'lang', 'lengde'],
    weight: 0.8
  },
  body: {
    terms: ['fylde', 'fyldig', 'kropp', 'rik', 'intens'],
    weight: 0.8
  },
  acidity: {
    terms: ['friskhet', 'frisk', 'syre', 'syrlig', 'saftig'],
    weight: 0.8
  },
  sweetness: {
    terms: ['soedme', 'soet', 'toerr', 'halvtoerr'],
    weight: 0.8
  },
  texture: {
    terms: ['myk', 'rund', 'bloet', 'silkemyk', 'kremaktig', 'fast'],
    weight: 0.8
  },
  general: {
    terms: ['god', 'fin', 'pen', 'behagelig', 'tiltalende'],
    weight: 0.8
  }
} as const satisfies Record<string, SubcategoryData>;

// Type extraction helpers
export type WineCategoryKey = keyof typeof WINE_CATEGORIES;
export type GenericCategoryKey = keyof typeof GENERIC_STRUCTURE_TERMS;
```

**index.ts** - Public exports:
```typescript
export * from './types';
export { WINE_CATEGORIES, GENERIC_STRUCTURE_TERMS } from './hierarchy';
export type { WineCategoryKey, GenericCategoryKey } from './hierarchy';
```

Note: Use ASCII-safe identifiers (baer not bær, toerket not tørket) to avoid encoding issues. The actual Norwegian lemmas with special characters are stored in the terms arrays.
  </action>
  <verify>
Run TypeScript compiler to check for type errors:
```bash
npx tsc --noEmit src/lib/categories/index.ts
```
Verify files exist:
```bash
ls -la src/lib/categories/
```
  </verify>
  <done>
Three files created in src/lib/categories/ with:
- Type definitions for hierarchical categories
- WINE_CATEGORIES with 6 main categories and subcategories
- GENERIC_STRUCTURE_TERMS with low weight (0.8)
- All types compile without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create validation script for category structure</name>
  <files>scripts/validate-categories.ts</files>
  <action>
Create validation script following Phase 1 patterns (uses tsx, dotenv):

```typescript
import { config } from 'dotenv';
import { readFile } from 'fs/promises';
import path from 'path';

config({ path: '.env.local' });

import { norwegianLemmas } from '../src/lib/lemmatizeAndWeight';
import { WINE_CATEGORIES, GENERIC_STRUCTURE_TERMS } from '../src/lib/categories';

interface ValidationResult {
  success: boolean;
  errors: string[];
  warnings: string[];
  stats: {
    totalOldTerms: number;
    totalNewTerms: number;
    categorizedTerms: number;
    uncategorizedFromOld: number;
    duplicates: number;
    mainCategories: number;
    subcategories: number;
  };
}

async function validateCategories(): Promise<ValidationResult> {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Build flat map of all terms in new structure
  const newTerms = new Map<string, string>(); // term -> category path
  let subcategoryCount = 0;

  // Process WINE_CATEGORIES
  for (const [mainCat, subcats] of Object.entries(WINE_CATEGORIES)) {
    for (const [subCat, data] of Object.entries(subcats)) {
      subcategoryCount++;
      for (const term of data.terms) {
        const termPath = `${mainCat}/${subCat}`;
        if (newTerms.has(term)) {
          errors.push(`DUPLICATE: "${term}" in ${termPath} AND ${newTerms.get(term)}`);
        }
        newTerms.set(term, termPath);
      }
    }
  }

  // Process GENERIC_STRUCTURE_TERMS
  for (const [cat, data] of Object.entries(GENERIC_STRUCTURE_TERMS)) {
    subcategoryCount++;
    for (const term of data.terms) {
      const termPath = `GENERIC/${cat}`;
      if (newTerms.has(term)) {
        errors.push(`DUPLICATE: "${term}" in ${termPath} AND ${newTerms.get(term)}`);
      }
      newTerms.set(term, termPath);
    }
  }

  // Check all old lemmas can be mapped
  const oldLemmas = new Set<string>();
  const uncategorized: string[] = [];

  for (const [word, data] of Object.entries(norwegianLemmas)) {
    oldLemmas.add(data.lemma);
    oldLemmas.add(word);
  }

  for (const term of oldLemmas) {
    // Normalize: replace Norwegian chars for lookup
    const normalized = term
      .replace(/æ/g, 'ae')
      .replace(/ø/g, 'oe')
      .replace(/å/g, 'aa')
      .toLowerCase();

    if (!newTerms.has(term) && !newTerms.has(normalized)) {
      uncategorized.push(term);
    }
  }

  // Some uncategorized terms are expected (variants, inflections)
  // Warn only if core lemmas are missing
  const coreLemmas = ['balanse', 'struktur', 'tannin', 'solbaer', 'kirsbaer', 'eple', 'pepper'];
  for (const core of coreLemmas) {
    const found = newTerms.has(core) ||
      [...newTerms.keys()].some(k => k.includes(core.replace(/ae|oe/g, '')));
    if (!found) {
      warnings.push(`CORE LEMMA MISSING: "${core}" not found in new structure`);
    }
  }

  // Verify berry merge
  const expectedBerries = ['solbaer', 'bjoernbaer', 'blabaer', 'morell', 'kirsbaer', 'jordbaer', 'bringbaer', 'rips'];
  const berryCategory = WINE_CATEGORIES.Frukt.baer.terms as readonly string[];
  const missingBerries = expectedBerries.filter(b => !berryCategory.includes(b));
  if (missingBerries.length > 0) {
    errors.push(`BERRY MERGE INCOMPLETE: Missing ${missingBerries.join(', ')}`);
  }

  // Verify weight inversion (generic < specific)
  const genericWeights = Object.values(GENERIC_STRUCTURE_TERMS).map(d => d.weight);
  const specificWeights = Object.values(WINE_CATEGORIES)
    .flatMap(cat => Object.values(cat))
    .map(d => d.weight);

  const maxGeneric = Math.max(...genericWeights);
  const minSpecific = Math.min(...specificWeights);

  if (maxGeneric >= minSpecific) {
    warnings.push(`WEIGHT OVERLAP: Generic max (${maxGeneric}) >= Specific min (${minSpecific})`);
  }

  // Count stats
  const mainCategoryCount = Object.keys(WINE_CATEGORIES).length;

  return {
    success: errors.length === 0,
    errors,
    warnings,
    stats: {
      totalOldTerms: oldLemmas.size,
      totalNewTerms: newTerms.size,
      categorizedTerms: newTerms.size,
      uncategorizedFromOld: uncategorized.length,
      duplicates: errors.filter(e => e.startsWith('DUPLICATE')).length,
      mainCategories: mainCategoryCount,
      subcategories: subcategoryCount
    }
  };
}

// Run validation
validateCategories().then(result => {
  console.log('\n========================================');
  console.log('   CATEGORY VALIDATION RESULTS');
  console.log('========================================\n');

  console.log(`Status: ${result.success ? '✓ PASS' : '✗ FAIL'}\n`);

  console.log('STATISTICS:');
  console.log(`  Main categories: ${result.stats.mainCategories}`);
  console.log(`  Subcategories: ${result.stats.subcategories}`);
  console.log(`  Terms in new structure: ${result.stats.totalNewTerms}`);
  console.log(`  Terms in old structure: ${result.stats.totalOldTerms}`);
  console.log(`  Uncategorized from old: ${result.stats.uncategorizedFromOld}`);
  console.log(`  Duplicates found: ${result.stats.duplicates}`);

  if (result.errors.length > 0) {
    console.log('\n✗ ERRORS:');
    result.errors.forEach(e => console.log(`  ${e}`));
  }

  if (result.warnings.length > 0) {
    console.log('\n⚠ WARNINGS:');
    result.warnings.forEach(w => console.log(`  ${w}`));
  }

  console.log('\n========================================\n');

  process.exit(result.success ? 0 : 1);
});
```

Key validations:
1. No duplicate terms across any categories
2. Berry merge includes all expected berries (solbær, bjørnebær, etc.)
3. Weight hierarchy maintained (generic 0.8 < specific 1.3+)
4. Core lemmas present in new structure
  </action>
  <verify>
Run the validation script:
```bash
npx tsx scripts/validate-categories.ts
```
Expected output: PASS status with 6 main categories, no duplicates, berry merge complete.
  </verify>
  <done>
Validation script created and passes with:
- 6 main categories detected
- All berry terms in baer subcategory
- No duplicate terms
- Generic weights (0.8) less than specific weights (1.3+)
- Script exits with code 0
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation succeeds for categories module
2. Validation script runs without errors
3. All 6 main categories present: Frukt, Krydder, Urter, Blomster, Eik/fat, Mineral
4. Berry merge verified (8 berry terms in single subcategory)
5. Weight hierarchy verified (generic 0.8 < specific 1.3+)
</verification>

<success_criteria>
- src/lib/categories/ module exists with types.ts, hierarchy.ts, index.ts
- scripts/validate-categories.ts exists and runs successfully
- No TypeScript compilation errors
- Validation script outputs PASS status
- 6 main categories with subcategories defined
- GENERIC_STRUCTURE_TERMS defined with weight 0.8
</success_criteria>

<output>
After completion, create `.planning/phases/02-category-restructuring/02-01-SUMMARY.md`
</output>
