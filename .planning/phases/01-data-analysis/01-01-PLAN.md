---
phase: 01-data-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/analyze-wine-vocabulary.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Script fetches all wines from Supabase with pagination"
    - "Smell and taste terms extracted and frequency-counted"
    - "Results exported to JSON file"
  artifacts:
    - path: "scripts/analyze-wine-vocabulary.ts"
      provides: "Wine vocabulary extraction and frequency analysis"
      min_lines: 80
    - path: "wine-vocabulary-analysis.json"
      provides: "Frequency analysis results"
      contains: "smellTermFrequency"
  key_links:
    - from: "scripts/analyze-wine-vocabulary.ts"
      to: "@supabase/supabase-js"
      via: "createClient import"
      pattern: "createClient.*supabase"
    - from: "scripts/analyze-wine-vocabulary.ts"
      to: "src/lib/lemmatizeAndWeight.ts"
      via: "stopwords import"
      pattern: "import.*stopwords.*lemmatizeAndWeight"
---

<objective>
Extract all wine smell/taste notes from Supabase and analyze term frequency.

Purpose: Understand the actual Norwegian wine vocabulary used in the database before modifying the lemma dictionary. This data-driven approach ensures we add terms people actually use.
Output: JSON file with frequency-sorted lists of smell, taste, and color terms.
</objective>

<execution_context>
@/Users/kristianoftedal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kristianoftedal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-analysis/01-RESEARCH.md
@src/lib/lemmatizeAndWeight.ts
@src/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Setup and create extraction script</name>
  <files>scripts/analyze-wine-vocabulary.ts, package.json</files>
  <action>
1. Install tsx as dev dependency: `npm install --save-dev tsx`

2. Create `scripts/analyze-wine-vocabulary.ts` with:
   - Import createClient from @supabase/supabase-js
   - Import stopwords from ../src/lib/lemmatizeAndWeight
   - Import writeFile from fs/promises
   - Import Wine type from ../src/lib/types

3. Implement fetchAllWines() function:
   - Create Supabase client using NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY from process.env
   - Use pagination with pageSize 1000
   - CRITICAL: Use .order('id') with .range() to ensure consistent pagination
   - Select: id, name, smell, taste, color
   - Return Wine[] array

4. Implement tokenize(text: string | null) function:
   - Return empty array for null/empty text
   - Lowercase the text
   - Remove punctuation with regex: /[.,\/#!$%\^&\*;:{}=\-_`~()]/g
   - Split on whitespace
   - Filter out words in stopwords Set
   - Filter out words with length 0

5. Implement analyzeFrequency(texts: (string | null)[]) function:
   - Create Map<string, number> for frequency counting
   - For each text, tokenize and count word occurrences
   - Use pattern: frequency.set(word, (frequency.get(word) || 0) + 1)
   - Return the Map

6. Add package.json script:
   ```json
   "analyze": "tsx scripts/analyze-wine-vocabulary.ts"
   ```

WHY this approach: Research confirms tsx is 5-10x faster than ts-node. Map provides O(1) frequency counting. Pagination with .order() is mandatory for consistent results.
  </action>
  <verify>
Run `npm run analyze` and confirm:
- Script starts without import errors
- "Fetching wines from Supabase..." appears in console
- No runtime errors
  </verify>
  <done>
Script exists, installs, and runs without errors. Supabase connection works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Run frequency analysis and export results</name>
  <files>scripts/analyze-wine-vocabulary.ts</files>
  <action>
1. Implement main() async function:
   - Call fetchAllWines() to get all wine records
   - Log total wines fetched
   - Analyze frequency for:
     - smellFreq = analyzeFrequency(wines.map(w => w.smell))
     - tasteFreq = analyzeFrequency(wines.map(w => w.taste))
     - colorFreq = analyzeFrequency(wines.map(w => w.color))

2. Create AnalysisResults type:
   ```typescript
   interface AnalysisResults {
     totalWines: number;
     smellTermFrequency: [string, number][];
     tasteTermFrequency: [string, number][];
     colorTermFrequency: [string, number][];
     analyzedAt: string;
   }
   ```

3. Build results object:
   - Convert Maps to sorted arrays: Array.from(freq.entries()).sort((a,b) => b[1] - a[1])
   - Take top 100 for smell/taste, top 50 for color
   - Add ISO timestamp for analyzedAt

4. Export to JSON:
   - Use writeFile with path 'wine-vocabulary-analysis.json'
   - Use JSON.stringify with 2-space indent
   - IMPORTANT: Use Object.fromEntries() if serializing Maps directly (Map -> JSON returns {})

5. Add console output:
   - Print total wines analyzed
   - Print top 10 smell and taste terms with counts
   - Print "Analysis complete!" message

6. Call main().catch(console.error) at end of file
  </action>
  <verify>
Run `npm run analyze` and confirm:
- wine-vocabulary-analysis.json is created
- JSON contains smellTermFrequency array with [term, count] pairs
- Top terms printed to console are Norwegian wine descriptors (not stopwords)
  </verify>
  <done>
JSON file exists with totalWines > 0, smellTermFrequency and tasteTermFrequency arrays sorted by frequency descending.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `cat wine-vocabulary-analysis.json | head -50` shows valid JSON with frequency data
2. Top terms are actual wine descriptors (frukt, b√¶r, krydder, etc.) not stopwords (og, i, av)
3. totalWines field shows number of wines analyzed from database
</verification>

<success_criteria>
- scripts/analyze-wine-vocabulary.ts exists and runs without errors
- wine-vocabulary-analysis.json contains frequency analysis
- Smell and taste term frequencies sorted descending
- Stopwords filtered out from results
- Script completes in reasonable time (< 2 minutes)
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-analysis/01-01-SUMMARY.md`
</output>
