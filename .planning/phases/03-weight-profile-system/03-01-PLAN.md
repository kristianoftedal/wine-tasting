---
phase: 03-weight-profile-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/profiles/types.ts
  - src/lib/profiles/weights.ts
  - src/lib/profiles/config.ts
  - src/lib/profiles/index.ts
  - src/lib/lemmatizeAndWeight.ts
autonomous: true

must_haves:
  truths:
    - "Three weight profiles exist: inverted, moderate, data-driven"
    - "Environment variable NEXT_PUBLIC_WEIGHT_PROFILE switches active profile"
    - "Profile weights replace base weights in lemmatization"
    - "Invalid profile name falls back to inverted profile"
    - "TypeScript types ensure profile structure is correct"
  artifacts:
    - path: "src/lib/profiles/types.ts"
      provides: "WeightProfile interface and ProfileName type"
      exports: ["WeightProfile", "ProfileName"]
    - path: "src/lib/profiles/weights.ts"
      provides: "Three profile definitions with category weights"
      exports: ["INVERTED_PROFILE", "MODERATE_PROFILE", "DATA_DRIVEN_PROFILE"]
    - path: "src/lib/profiles/config.ts"
      provides: "Profile selection from environment variable"
      exports: ["getActiveProfile", "getCategoryWeight"]
    - path: "src/lib/profiles/index.ts"
      provides: "Public exports for profiles module"
    - path: "src/lib/lemmatizeAndWeight.ts"
      provides: "Lemmatization using active profile weights"
      contains: "getCategoryWeight"
  key_links:
    - from: "src/lib/profiles/config.ts"
      to: "process.env.NEXT_PUBLIC_WEIGHT_PROFILE"
      via: "environment variable read"
      pattern: "process\\.env\\.NEXT_PUBLIC_WEIGHT_PROFILE"
    - from: "src/lib/lemmatizeAndWeight.ts"
      to: "src/lib/profiles/config.ts"
      via: "import getCategoryWeight"
      pattern: "import.*getCategoryWeight.*from.*profiles"
---

<objective>
Create three switchable weight profiles (inverted, moderate, data-driven) for category-level scoring weights.

Purpose: Enable different scoring strategies to be tested and compared. Inverted profile rewards specific tasting descriptors, moderate provides a balanced approach, and data-driven uses actual database frequency to set weights.

Output: A profiles module with typed weight definitions and environment-based profile selection, integrated into the lemmatization system.
</objective>

<execution_context>
@/Users/kristianoftedal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kristianoftedal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-weight-profile-system/03-CONTEXT.md
@.planning/phases/03-weight-profile-system/03-RESEARCH.md
@src/lib/categories/types.ts
@src/lib/categories/hierarchy.ts
@src/lib/lemmatizeAndWeight.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create profiles module with type definitions and weight profiles</name>
  <files>
    src/lib/profiles/types.ts
    src/lib/profiles/weights.ts
    src/lib/profiles/index.ts
  </files>
  <action>
Create the profiles module structure:

**src/lib/profiles/types.ts:**
- Import MainCategory from '../categories/types'
- Define WeightProfile interface with:
  - readonly name: string
  - readonly description: string
  - readonly weights: Record mapping (MainCategory | 'GENERIC') to number
- Define ProfileName type as union: 'inverted' | 'moderate' | 'data-driven'

**src/lib/profiles/weights.ts:**
- Import types from './types' and MainCategory from categories
- Create INVERTED_PROFILE (as const satisfies WeightProfile):
  - Frukt: 2.0, Krydder: 2.2, Urter: 2.0, Blomster: 2.0, Eik/fat: 2.5, Mineral: 2.0
  - GENERIC: 1.0
- Create MODERATE_PROFILE (as const satisfies WeightProfile):
  - Frukt: 1.8, Krydder: 2.0, Urter: 1.8, Blomster: 1.8, Eik/fat: 2.2, Mineral: 1.8
  - GENERIC: 1.2
- Create DATA_DRIVEN_PROFILE (as const satisfies WeightProfile):
  - Use normalized frequencies from Phase 1 analysis (common = higher weight)
  - Frukt: 2.2 (highest frequency), Krydder: 1.4, Urter: 1.0, Blomster: 0.9
  - Eik/fat: 1.1, Mineral: 1.0, GENERIC: 2.5 (most common terms)

**src/lib/profiles/index.ts:**
- Re-export types from './types'
- Re-export profiles from './weights'

Use `as const satisfies WeightProfile` pattern for compile-time type checking and literal type inference.
  </action>
  <verify>
Run `npx tsc --noEmit` - TypeScript compiles without errors.
Verify profiles import correctly: `node -e "import('./src/lib/profiles/index.ts')"`
  </verify>
  <done>
Three weight profiles defined with correct category weights. TypeScript types ensure all categories are covered. Profiles use as const satisfies pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create profile configuration with environment variable selection</name>
  <files>
    src/lib/profiles/config.ts
    src/lib/profiles/index.ts
  </files>
  <action>
Create the profile selection logic:

**src/lib/profiles/config.ts:**
- Import ProfileName and WeightProfile from './types'
- Import all three profiles from './weights'
- Import MainCategory from '../categories/types'
- Create PROFILES record: Record&lt;ProfileName, WeightProfile&gt; mapping names to profile objects
- Create getActiveProfile() function:
  - Read process.env.NEXT_PUBLIC_WEIGHT_PROFILE
  - Cast to ProfileName (with fallback to 'inverted')
  - Validate profile exists in PROFILES registry
  - If invalid, console.warn and return INVERTED_PROFILE as fallback
  - Return the selected profile
- Create getCategoryWeight(category: MainCategory | 'GENERIC'): number function:
  - Get active profile via getActiveProfile()
  - Return weights[category] from active profile

**Update src/lib/profiles/index.ts:**
- Add exports for getActiveProfile and getCategoryWeight from './config'

The config module is the single source of truth for profile selection. Always validate profile name to handle typos or missing env var gracefully.
  </action>
  <verify>
Run `npx tsc --noEmit` - TypeScript compiles without errors.
Test profile selection: create a small test that imports getCategoryWeight and verifies it returns expected values.
  </verify>
  <done>
Profile selection works via NEXT_PUBLIC_WEIGHT_PROFILE environment variable. Invalid profile names fall back to inverted profile with console warning.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate profiles into lemmatizeAndWeight</name>
  <files>
    src/lib/lemmatizeAndWeight.ts
  </files>
  <action>
Modify lemmatizeAndWeight.ts to use profile weights:

1. Add import at top:
   ```typescript
   import { getCategoryWeight } from './profiles';
   ```

2. Modify lemmatizeAndWeight function to use profile weights instead of hardcoded weights:
   - When a lemma is found in norwegianLemmas:
     - Get the categoryPath.main from the lemma data
     - Call getCategoryWeight(lemmaData.categoryPath.main) to get profile weight
     - Use profile weight instead of lemmaData.weight for weightSum calculation
   - When lemma is NOT found (unknown term):
     - Use getCategoryWeight('GENERIC') instead of hardcoded 1.0

3. Key change in the forEach loop:
   ```typescript
   if (lemmaData) {
     const profileWeight = lemmaData.categoryPath
       ? getCategoryWeight(lemmaData.categoryPath.main)
       : getCategoryWeight('GENERIC');

     lemmatized.push({
       original: word,
       lemma: lemmaData.lemma,
       weight: profileWeight,  // Use profile weight
       category: lemmaData.category
     });
     weightSum += profileWeight;
   } else {
     const genericWeight = getCategoryWeight('GENERIC');
     lemmatized.push({
       original: word,
       lemma: word,
       weight: genericWeight,
       category: 'ukjent'
     });
     weightSum += genericWeight;
   }
   ```

IMPORTANT: Profile weight REPLACES base weight (not multiplies). The hardcoded weights in norwegianLemmas become fallback/documentation only - actual scoring uses profile weights.

Do NOT remove the existing weight field from norwegianLemmas - keep for backwards compatibility and reference.
  </action>
  <verify>
Run `npx tsc --noEmit` - TypeScript compiles without errors.
Run `npm run build` - Application builds successfully.
Manual verification: The lemmatizeAndWeight function now uses profile weights for scoring.
  </verify>
  <done>
lemmatizeAndWeight uses active profile weights. Specific descriptors get profile-defined weights (e.g., 2.0 for Frukt in inverted profile). Generic terms get GENERIC weight from profile. Unknown terms also use GENERIC profile weight.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compiles: `npx tsc --noEmit` passes
2. Application builds: `npm run build` succeeds
3. Profile module exists at src/lib/profiles/ with types.ts, weights.ts, config.ts, index.ts
4. Three profiles defined: inverted, moderate, data-driven
5. Environment variable NEXT_PUBLIC_WEIGHT_PROFILE controls active profile
6. lemmatizeAndWeight uses getCategoryWeight for all weight lookups
</verification>

<success_criteria>
- [ ] Three weight profiles exist with correct weight ranges
- [ ] Inverted: specific 2.0-2.5, generic 1.0
- [ ] Moderate: specific 1.8-2.2, generic 1.2
- [ ] Data-driven: weights based on frequency (GENERIC highest at 2.5)
- [ ] Profile selection via NEXT_PUBLIC_WEIGHT_PROFILE env var
- [ ] Invalid profile gracefully falls back to inverted
- [ ] lemmatizeAndWeight uses profile weights (not hardcoded weights)
- [ ] TypeScript compilation passes
- [ ] Application build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-weight-profile-system/03-01-SUMMARY.md`
</output>
