---
phase: 05-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/validate-scoring.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Validation script compares all three profiles for same test cases"
    - "Test cases contrast specific terms vs generic terms"
    - "Script outputs weights and pass/fail for each profile"
  artifacts:
    - path: "scripts/validate-scoring.ts"
      provides: "Validation comparison script"
      exports: ["main"]
    - path: "package.json"
      provides: "npm run validate-scoring command"
      contains: "validate-scoring"
  key_links:
    - from: "scripts/validate-scoring.ts"
      to: "src/lib/lemmatizeAndWeight.ts"
      via: "dynamic import for fresh profile weights"
      pattern: "import.*lemmatizeAndWeight"
---

<objective>
Create validation script that compares scoring behavior across all three weight profiles using defined test cases.

Purpose: Enable systematic verification that the inverted profile correctly rewards specific tasting notes over generic terms
Output: Working `npm run validate-scoring` command that produces comparison output
</objective>

<execution_context>
@/Users/kristianoftedal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kristianoftedal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-validation/05-RESEARCH.md

Source files:
@src/lib/lemmatizeAndWeight.ts
@src/lib/profiles/weights.ts
@src/lib/profiles/config.ts
@scripts/recalculate-scores.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validate-scoring.ts with test cases and multi-profile comparison</name>
  <files>scripts/validate-scoring.ts, package.json</files>
  <action>
Create `scripts/validate-scoring.ts` following the pattern from recalculate-scores.ts:

1. Define ValidationTestCase interface:
   - id: string identifier
   - description: string explaining what's tested
   - text1: string (contains specific descriptors)
   - text2: string (contains generic descriptors)
   - expectation: 'text1_higher' | 'text2_higher' | 'similar'
   - category: 'specific_vs_generic' | 'same_category' | 'edge_case'

2. Create 15-20 test cases covering:
   - Berry terms vs structure terms (5 cases)
   - Oak/barrel terms vs quality adjectives (3 cases)
   - Spice terms vs acidity terms (3 cases)
   - Herb/flower terms vs texture terms (2 cases)
   - Edge cases: mixed specific+generic (2 cases)

   Example test cases:
   ```typescript
   {
     id: 'berry-vs-structure-1',
     description: 'Specific berry notes should score higher than generic structure',
     text1: 'solbaer og kirsebær',
     text2: 'balansert og frisk',
     expectation: 'text1_higher',
     category: 'specific_vs_generic'
   }
   ```

3. Implement runValidation function that:
   - For each profile (inverted, moderate, data-driven):
     - Sets process.env.NEXT_PUBLIC_WEIGHT_PROFILE
     - Uses vi.resetModules pattern (or dynamic import with cache busting) to get fresh weights
     - Computes weightSum for text1 and text2
     - Records ratio (text1/text2) and pass/fail

   CRITICAL: Use dynamic import pattern to avoid module caching:
   ```typescript
   // Clear module cache and reimport for fresh profile weights
   delete require.cache[require.resolve('../src/lib/lemmatizeAndWeight')];
   const { lemmatizeAndWeight } = await import('../src/lib/lemmatizeAndWeight');
   ```

4. Output comparison matrix showing:
   - Test case ID and description
   - Weights for text1 and text2 per profile
   - Ratio per profile
   - Pass/fail per profile
   - Overall pass rate

5. Add npm script: "validate-scoring": "tsx scripts/validate-scoring.ts"

Use these specific Norwegian terms from lemmatizeAndWeight.ts:
- Specific (Frukt 2.0): solbær, kirsebær, bringebær, blåbær, plomme
- Specific (Krydder 2.2): pepper, nellik, kanel
- Specific (Eik/fat 2.5): eik, fat, vanilje, fatpreg
- Specific (Urter 2.0): timian, rosmarin, urter
- Generic (1.0): balansert, frisk, fyldig, struktur, elegant, god

DO NOT use synthetic wine data or database queries - use hardcoded test case strings.
  </action>
  <verify>
  ```bash
  # Script runs without errors
  npx tsx scripts/validate-scoring.ts

  # npm command works
  npm run validate-scoring
  ```
  </verify>
  <done>
  - validate-scoring.ts exists with 15+ test cases
  - Script compares all three profiles
  - Output shows pass/fail for inverted profile rewarding specific terms
  - npm run validate-scoring works
  </done>
</task>

</tasks>

<verification>
```bash
# Verify script exists and has test cases
grep -c "id:" scripts/validate-scoring.ts  # Should show 15+

# Verify all three profiles are compared
grep -E "inverted|moderate|data-driven" scripts/validate-scoring.ts

# Run validation
npm run validate-scoring
```
</verification>

<success_criteria>
- validate-scoring.ts script created with 15+ test cases
- Script compares all three weight profiles
- Output shows per-profile weights and pass/fail status
- npm run validate-scoring command works
- Inverted profile passes majority of specific_vs_generic test cases
</success_criteria>

<output>
After completion, create `.planning/phases/05-validation/05-01-SUMMARY.md`
</output>
